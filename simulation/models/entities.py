"""
Core domain entities for the Auto-Registration System.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
import uuid


class RegistrationStatus(Enum):
    """Status of a student's registration for a course."""
    WAITLISTED = "waitlisted"
    REGISTERED = "registered"
    DROPPED = "dropped"
    REJECTED = "rejected"


class CourseBookingState(Enum):
    """State of course booking availability."""
    BOOKING_CLOSED = "booking_closed"      # Before registration opens
    BOOKING_OPEN = "booking_open"          # Registration is open
    COURSE_STARTED = "course_started"      # Course has begun, only fills from waitlist
    COURSE_COMPLETED = "course_completed"  # No more registrations


@dataclass
class Student:
    """Represents a student in the system."""
    student_id: str
    name: str
    email: str
    gpa: float  # 0.0 to 4.0
    major: str
    year: int  # 1-4 for undergrad, 5+ for grad
    interests: list[str] = field(default_factory=list)
    completed_courses: list[str] = field(default_factory=list)
    
    def __hash__(self):
        return hash(self.student_id)


@dataclass
class Course:
    """Represents a course offered by the university."""
    course_id: str
    name: str
    department: str
    capacity: int
    current_enrollment: int = 0
    prerequisites: list[str] = field(default_factory=list)
    tags: list[str] = field(default_factory=list)  # For interest matching
    booking_state: CourseBookingState = CourseBookingState.BOOKING_CLOSED
    booking_opens_at: Optional[datetime] = None
    min_gpa: float = 0.0  # Minimum GPA requirement
    preferred_years: list[int] = field(default_factory=lambda: [1, 2, 3, 4])
    
    @property
    def available_seats(self) -> int:
        return max(0, self.capacity - self.current_enrollment)
    
    @property
    def has_vacancy(self) -> bool:
        return self.available_seats > 0
    
    def __hash__(self):
        return hash(self.course_id)


@dataclass
class CourseApplication:
    """
    Represents a student's application for a course.
    This is what goes into the priority queue.
    """
    application_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    student_id: str = ""
    course_id: str = ""
    priority_rank: int = 0  # Student's preference (1 = most wanted)
    applied_at: datetime = field(default_factory=datetime.utcnow)
    status: RegistrationStatus = RegistrationStatus.WAITLISTED
    
    # Computed score components (stored for transparency)
    gpa_score: float = 0.0
    interest_score: float = 0.0
    time_score: float = 0.0
    year_score: float = 0.0
    composite_score: float = 0.0
    
    def __hash__(self):
        return hash(self.application_id)


@dataclass
class StudentCoursePreferences:
    """
    The shortlisted courses for a student, in priority order.
    Generated by your recommendation system.
    """
    student_id: str
    course_ids: list[str]  # Ordered by priority (index 0 = highest priority)
    generated_at: datetime = field(default_factory=datetime.utcnow)
    
    def get_priority(self, course_id: str) -> int:
        """Get priority rank for a course (1-indexed, lower is better)."""
        try:
            return self.course_ids.index(course_id) + 1
        except ValueError:
            return 999  # Not in preferences


@dataclass
class AllocationResult:
    """Result of an allocation attempt."""
    student_id: str
    course_id: str
    success: bool
    status: RegistrationStatus
    message: str
    waitlist_position: Optional[int] = None
    score: Optional[float] = None